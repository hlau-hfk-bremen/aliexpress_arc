'use strict';

console.log('Ozone INCLUDE JS PAGE: 20230426 09:00');
console.log('*** This version MUST FIND a CMP and polls until we discover the CMP, MAX of 600ms tho ***');

// Just change these when you move the files from dev to prod (BBC)
// for bbc these were:
// https://prebid.the-ozone-project.com/hw/bbc/adUnits.min.js and
// https://prebid.the-ozone-project.com/hw/bbc/prebid-bbc-ozone.min.js
var configVars = {
    ozonePrebidFile_src: 'https://prebid.the-ozone-project.com/hw/bbc/prebid-bbc-ozone.min.js', /* pbjs.installedModules == ["schain","consentManagement","consentManagementUsp","gdprEnforcement","userId","id5IdSystem","criteoIdSystem","identityLinkIdSystem","parrableIdSystem","ozoneBidAdapter","lotamePanoramaIdSystem","sharedIdSystem","fabrickIdSystem","permutiveRtdProvider","rtdModule","liveIntentIdSystem","priceFloors","sizeMappingV2"]*/
    includeMenu: false,
    deleteUspapi: false /* ONLY FOR TESTING! */
}
var PREBID_TIMEOUT = 2000;

var testgroup = Math.floor(Math.random() * 100);

var pbjs = pbjs || {};
pbjs.que = pbjs.que || [];
var startTime = Date.now();
// Debugging : we will write out console log info when GET param pbjs_debug=true exists.
var isPbjs = document.location.search.match('pbjs_debug=true');

function ozoneLog() {
    if(!isPbjs) return;
    let txt = arguments[0];
    if(arguments.length > 1) {
        txt = arguments;
    }
    console.log(`%cOZONE wrapper : ${Date.now() - startTime}ms`, 'background-color: #AFA; border-radius:5px', txt);
}
function ozoneError() {
    if(!isPbjs) return;
    let txt = arguments[0];
    if(arguments.length > 1) {
        txt = arguments;
    }
    console.error(`%cOZONE wrapper:  ${Date.now() - startTime}ms`, 'background-color: #FAA; border-radius:5px', txt);
}

var ozoneadunits = ozoneadunits || {};
ozoneadunits.cmd = ozoneadunits.cmd || [];

try {
    ozoneLog('googletag cmd 1 is ', JSON.parse(JSON.stringify(window.googletag.cmd)));
} catch(e) {
    ozoneLog('googletag cmd does not exist (1)');
}

// have we already missed the googletag.enableServices call?
// python-type just do it & catch errors!
try {
    let earlySlots = window.googletag.pubads().getSlots();
    if(earlySlots.length > 0) {
        ozoneError(`ozone was loaded too late to intercept enableServices; googletag.pubads().getSlots() contains ${earlySlots.length} item(s)`);
    }
} catch (e) {
    ozoneLog(`ozone pbjs.js was loaded early enough to intercept enableServices :-)`);

    // Add my own listener for googletag.enableServices so I can call the prebid auction as soon as possible after
    // googletag.defineSlot calls have been done
    window.googletag = window.googletag || {};
    window.googletag.cmd = window.googletag.cmd || [];

    try {
        ozoneLog('googletag cmd 2 is ', JSON.parse(JSON.stringify(window.googletag.cmd)));
    } catch(e) {
        ozoneError('googletag cmd does not exist (2)');
    }

    googletag.cmd.push(function () {
        // verify gpt enableServices function exists:
        var gpt = window.googletag;
        if (!gpt.enableServices) {
            ozoneError('could not bind to gpt googletag api');
            return;
        }
        ozoneLog('disabling initialLoad');
        window.googletag.pubads().disableInitialLoad();
        var fGptEnableServices = gpt.enableServices;

        // NOTE capturing display() might not be a good idea - only slots that have had display() called are eligible to be refreshed. disableInitialLoad to stop the adserver being called.
        // https://developers.google.com/publisher-tag/guides/control-ad-loading

        // wrap the googletag.enableServices method:
        gpt.enableServices = function () {
            ozoneLog('googletag.enableServices has been called!');
            let response = fGptEnableServices.apply(gpt, arguments);
            ozoneLog('going to call ozoneFetchBids');
            ozoneWrapper.ozoneFetchBids();

            ozoneLog('going to return from googletag.enableServices');
            return response;
        };
        ozoneLog('ozone captured googletag.enableServices');
    });

    try {
        ozoneLog('googletag cmd 3 is ', JSON.parse(JSON.stringify(window.googletag.cmd)));
    } catch(e) {
        ozoneError('googletag cmd does not exist (3)');
    }

}

var adunitsFile = document.createElement('script');
adunitsFile.src = 'https://prebid.the-ozone-project.com/hw2/OZONEBBC4784/8890582654/current/adUnits.min.js';
document.head.appendChild(adunitsFile);
ozoneLog('pbjs.js: after writing script tag to include adunits.js');

var ozonePrebidFile = document.createElement("script");
ozonePrebidFile.src = configVars.ozonePrebidFile_src;
document.head.appendChild(ozonePrebidFile);

var customPriceGranularityChoices = {
    "low": "low",
    "medium": "medium",
    "high": "high",
    "auto": "auto",
    "dense": "dense",
    "custom": {
        "buckets": []
    }
};

pbjs.que.push(function () {

    let pbjsConfig = {
        realTimeData: {
 "dataProviders": [
  {
   "name": "permutive",
   "waitForIt": true,
   "params": {
    "acBidders": [
     "ozone"
    ],
    "maxSegs": 500
   }
  }
 ],
 "auctionDelay": 50
},
        
        userSync: {
            userIds: [
                {
                    name: "sharedId",
                    storage: {
                        type: "html5",
                        name: "_sharedID",
                        expires: 365
                    }
                }
            ],
            filterSettings: {
                iframe: {
                    bidders: '*',
                    filter: 'include',
                    iframeEnabled: true
                }
            },
            syncDelay: 3000
        },

        ozone: {
            singleRequest: true,
            enhancedAdserverTargeting: false,
            

            
        },
        
        enableSendAllBids: true, 
        useBidCache: false,

        priceGranularity: customPriceGranularityChoices["auto"],

    }

    /**
     * Directly set the values of ozoneWrapper.cmpGdpr and ozoneWrapper.cmpUsp.
     * Once these are known, complete the ozone config object & call pbjs.setConfig, then switch out ozoneWrapper.cmd
     * to be an object, processing any stored commands.
     * @param count
     */
    function setCmpConfig(count) {

        ozoneLog('setCmpConfig called');

        // for testing:
        if(configVars.deleteUspapi) {
            ozoneError('WARNING - deleting window.__uspapi for testing');
            delete(window.__uspapi);
        }

        // if we've reached the timeout limit then just set all privacy to false:
        if(ozoneWrapper.tcfapiLocator.timerHasExpired()) {
            ozoneLog('TCF locator has run out of time; setting gdpr & usp to false now.');
            ozoneWrapper.cmpGdpr = false;
            ozoneWrapper.cmpUsp = false;
        }

        // conditionally add consentManagement if there's a CMP...
        // __tcfapi = v2, __cmp = v1, and USP *should* be __uspapi
        if(window.hasOwnProperty('__tcfapi') || ozoneWrapper.tcfapiLocator.timerHasExpired()) { // __tcfapi will always be there, inside or outside the GDPR region, though it might take some time to appear...
            if(ozoneWrapper.tcfapiLocator.timerHasExpired()) {
                ozoneLog('CMP locator timer has expired - continuing with fake final consentManagement');
            } else {
                ozoneLog('FOUND CMP - now trying to add pbjsConfig.consentManagement');
            }

            // We first iterate until we find gdpr true/false, and then move on to focus on finding USP true/false.
            // When we get on to looking for USP, if it's not there then it never will be, so we will return false for `not found` on the first attempt

            // __tcfapi ping is synchronous - we can loop this inline, no need to use promises or callbacks
            // BUT scope is a problem - let the functions directly set ozoneWrapper values.
            if(ozoneWrapper.cmpGdpr === null) {
                setTimeout(function() {
                    ozoneLog(`Not found a value for GDPR yet - Going to call setCmpConfig again (elapsed=${ozoneWrapper.tcfapiLocator.searchMsElapsed()}ms, gdpr=${ozoneWrapper.cmpGdpr}, usp=${ozoneWrapper.cmpUsp})...`);
                    ozoneWrapper.setCmpGdpr();
                    setCmpConfig();
                }, ozoneWrapper.tcfapiLocator.waitMsBeforeRetrying);
                return;
            }
            if(ozoneWrapper.cmpUsp === null) {
                // note - this is asynchronous! Send a completion function as arg to call when it returns.
                ozoneWrapper.setCmpUsp(
                    function() {
                        // we've not found usp from the CMP yet...
                        if(!ozoneWrapper.tcfapiLocator.timerHasExpired()) {
                            ozoneLog(`Going to call setCmpConfig again (elapsed=${ozoneWrapper.tcfapiLocator.searchMsElapsed()}ms, gdpr=${ozoneWrapper.cmpGdpr}, usp=${ozoneWrapper.cmpUsp})...`);
                            setCmpConfig();
                        } else {
                            ozoneLog('CMP is still not fully loaded yet & we are out of retries');
                            setCmpConfig();
                        }
                    }
                );
                return;
            }

            // success! we've got values for gdpr & usp
            ozoneLog(`CMP is fully loaded and we have values for gdpr (${ozoneWrapper.cmpGdpr}) and usp (${ozoneWrapper.cmpUsp})`);

            let consentObject = {};
            // both gdpr & usp are known
            if(ozoneWrapper.cmpGdpr) {
                consentObject.gdpr = {
 "cmpApi": "iab",
 "allowAuctionWithoutConsent": true,
 "timeout": 10000,
 "defaultGdprScope": true,
 "rules": [
  {
   "purpose": "storage",
   "enforcePurpose": true,
   "enforceVendor": true,
   "vendorExceptions": [
    "permutive"
   ]
  },
  {
   "purpose": "basicAds",
   "enforcePurpose": true,
   "enforceVendor": true,
   "vendorExceptions": []
  }
 ]
}
            }
            if(ozoneWrapper.cmpUsp) {
                consentObject.usp = {
 "cmpApi": "iab",
 "timeout": 10000
}
            }
            if(Object.keys(consentObject).length > 0) {
                ozoneLog(`adding consentManagement data protection object to prebid config: ${JSON.stringify(consentObject)}`);
                pbjsConfig.consentManagement = consentObject;
            } else {
                ozoneLog(`Will not add consentManagement object to pbjs config - no data protection applied here`);
            }

            // now we have all the info we need, set pbjs.config & process any ozoneWrapper.cmd commands

            pbjs.setConfig(pbjsConfig);

            let arrCommands = [];
            if (Array.isArray( ozoneWrapper.cmd )) {
                arrCommands = ozoneWrapper.cmd; // cmd was still an array (its original configuration)
            }
            ozoneLog(`setCmpConfig Executing ${arrCommands.length} stored up commands from ozoneWrapper.cmd.`);
            for (let i = 0; i < arrCommands.length; i++) {
                ozoneLog('setCmpConfig Executing pushed command no.' + i);
                (arrCommands[i])();
            }
            ozoneWrapper.cmd = {
                push: function (fn) {
                    fn();
                }
            }
        } else {
            if(!ozoneWrapper.tcfapiLocator.timerHasExpired()) {
                ozoneLog(`__tcfapi is not available yet - we need to wait. ${ozoneWrapper.tcfapiLocator.searchMsElapsed()}ms elapsed so far...`);
                setTimeout(function() {
                    setCmpConfig();
                }, ozoneWrapper.tcfapiLocator.waitMsBeforeRetrying);
            } else {
                ozoneLog('__tcfapi is not available yet & we are out of time');
            }
        }
    }

    ozoneWrapper.tcfapiLocator.timeStarted = Date.now(); // we can only look for ozoneWrapper.tcfapiLocatorTimeoutMs ms
    setCmpConfig();

});

    

var ozoneWrapper = {

    tcfapiLocator: {
        init: function() {
          ozoneWrapper.tcfapiLocator.timeoutMs = ozoneWrapper.tcfapiLocator.getTimeoutMs();
        },
        /**
         * we can override the tcf location timeout by adding &tcflocatems=123
         * @returns {string|number}
         */
        getTimeoutMs: function() {
            let t = document.location.search.match(/tcflocatems=\d+/);
            if(t) {
                let ret = parseInt(t[0].split('=')[1]);
                ozoneLog(`Setting the value of tcfapiLocator.timeoutMs to QS value of ${ret}`);
                return ret;
            }
            return 5000; // default value
        },
        /* this wraps up functionality for use while locating the window.__tcfapi function */
        timeoutMs: 5000, /* only try to discover the __ticapi function for a max of this ms */
        timeStarted: null,
        waitMsBeforeRetrying: 20,
        /**
         * return how many ms have elapsed since we started searching for the __tcfapi function
         * @returns {number}
         */
        searchMsElapsed: function() {
            if(ozoneWrapper.tcfapiLocator.timeStarted === null) {
                return 0;
            }
            return Date.now() - ozoneWrapper.tcfapiLocator.timeStarted;
        },
        /**
         * Simple check to see if our allowed time for finding __tcfpai has elapsed yet
         * @returns {boolean}
         */
        timerHasExpired: function() {
            if(ozoneWrapper.tcfapiLocator.timeStarted === null) {
                return false;
            }
            return (Date.now() - ozoneWrapper.tcfapiLocator.timeStarted > ozoneWrapper.tcfapiLocator.timeoutMs)
        }
    },

    adserverRequestSent: false,
    cmpGdpr: null,
    cmpUsp: null,
    cmd: [], /* this is a cmd holder like googletag for our pbjs config to wait until CMP loads, so we can find out whether GDPR applies */
    startPrebidTimeout: function(ms) {
        ozoneLog(`startPrebidTimeout called with ms value: ${ms}`);
        // note that the dom is probably still being generated at this point, so adunits.js isn't even being loaded yet.
        if (ozoneWrapper.adserverRequestSent) {
            ozoneLog('startPrebidTimeout - ads have already been requested, will not call for ads.');
            return;
        }
        ozoneadunits.cmd.push(function() {
            ozoneLog(`(inside ozoneadunits.cmd fn) Setting a timeout to call sendAdserverRequest after ${ms}ms`);
            setTimeout(function () {
                if (ozoneWrapper.adserverRequestSent) {
                    ozoneLog('prebid auction timeout handler - ads have already been requested, will not call for ads.');
                    return;
                }
                ozoneLog(`prebid auction call timed out after ${ms}ms - going to call sendAdServerRequest`);
                ozoneWrapper.sendAdserverRequest();
            }, ms);
        });
    },
    /**
     * This is the only function that publishers have to call.
     * check the page has finished loading, then check the divIds we want to request bids for
     * @param optionalDivIds - send an array of divIDs if you want to restrict to only these, else we will work on all adunits known to googletag
     * @return {boolean}
     */
    ozoneFetchBids: function(optionalDivIds) {
        ozoneLog('ozoneFetchBids: document.readyState = ' + document.readyState);
        if(document.readyState === 'loading') return false;

        ozoneWrapper.adserverRequestSent = false; // reset this else we won't be able to call refreshbids
        // new code - optionally restrict to a set of div ids
        let arrDivids = [];
        if(arguments.length > 0 ) {
            if(Array.isArray(arguments[0])) {
                ozoneLog('ozoneFetchBids received array as first arg (will use this as the set of div IDs to work on): ', arguments);
                arrDivids = arguments[0];
            } else {
                ozoneLog('ozoneFetchBids received args, but first element was NOT an array (eh? why) we will ignore it: ', arguments);
            }
        } else {
            ozoneLog('ozoneFetchBids will work on all adunits known to googletag');
        }

        ozoneLog('pushing fn into ozoneWrapper.cmd to call processAdunitsWhichExist');
        // updated code - now passing a list of div IDs to processAdunitsWhichExist
        window.ozoneadunits.cmd.push(function() {
            ozoneLog('*** adUnits have loaded so will call processAdunitsWhichExist now ***', arrDivids);
            ozoneWrapper.processAdunitsWhichExist(arrDivids);
        });
    },

    /**
     * We need to get to the targeting that was present on the googletag objects BEFORE we made any pbjs requests
     * & added additional targeting. Call: targetingManager.getInitialTargetingForDivId('someDivId')
     * @type Object {}
     */
    targetingManager: {
        // store key:[] for each key=divId
        initialTargeting: {},
        /**
         * @param divId
         */
        getInitialTargetingForDivId: function(divId) {
            if(this.initialTargeting.hasOwnProperty(divId)) {
                return this.initialTargeting[divId];
            }
            let slot = ozoneWrapper.getGoogletagSlotsForDivIds([divId])[0];
            this.initialTargeting[divId] = slot.getTargetingMap();
            // this.initialTargeting[divId] = slot.getTargetingKeys().map(k => {k: slot.getTargeting(k)});
            return this.initialTargeting[divId];
        }
    },

    /**
     * Common code to simplify when we want to get the URI to work on:
     */
    getUri: function() {
        return document.location.pathname.replace('/ozone/20220606-bbc-wrapper/bbc_test', '');
    },

    /**
     * UPDATED to receive a set of div IDs
     * Call this ONLY from inside window.ozoneadunits.cmd, so that adunits are definitely in the page
     *
     * @param arrDivids Array - use all if [] else restrict to those matching these div IDs
     */
    processAdunitsWhichExist: function(arrDivids) {
        // we are now using the (unique) targeting key value for 'position' to link the googletag slot with our adunits
        let goodAdUnits = []; // list of targeting.position IDs set by googletag setTargeting('position', 1)
        let sm = googletag.pubads().getSlots();
        ozoneLog('processAdunitsWhichExist getSlots found full list of googletag slots: ', JSON.parse(JSON.stringify(sm)));
        for(let i = 0; i < sm.length; i++) {
            let property = sm[i];
            let divId = property.getSlotElementId();
            if(arrDivids.length > 0 && arrDivids.indexOf(divId) === -1) {
                ozoneLog('processAdunitsWhichExist SKIPPING div ID : ' + divId);
                continue;
            } else {
                ozoneLog('processAdunitsWhichExist OK div ID : ' + divId);
            }

            // modify the uri if we're on the test server
            let matchSection = this.getMatchSectionFromUri(this.getUri()); // NOTE - this is guaranteed to return a string (key) in adunitNameRegexMatch
            ozoneLog(`matchSection from uri is: ${matchSection}`);
            this.pushAdunitForUri(goodAdUnits, matchSection, divId, this.targetingManager.getInitialTargetingForDivId(divId));
        }
        
        if(goodAdUnits.length < 1) {
            ozoneLog('processAdunitsWhichExist Found NO adunits to send to auction');
// NEW: 20220624 - call the adserver
            if(!ozoneWrapper.adserverRequestSent) {
                ozoneLog('Bidsbackhandler going to call sendAdserverRequest');
                ozoneWrapper.sendAdserverRequest(arrDivids);
            } else {
                ozoneLog('Bidsbackhandler will not call sendAdserverRequest - its already been called');
            }
            return;
        }
        ozoneLog('processAdunitsWhichExist got list of adunits to send to auction', JSON.parse(JSON.stringify(goodAdUnits)));
        ozoneLog('going to push the auction calling function into ozoneWrapper.cmd');
        if(ozoneWrapper.adserverRequestSent) {
            ozoneLog('Ads have already been requested! We will not continue with the auction.');
            return;
        }

        if(ozoneWrapper.adserverRequestSent) {
            ozoneLog('Ads have already been requested! We will not continue with the auction.');
            return;
        }
        ozoneWrapper.cmd.push(function () {
            pbjs.que.push(function () {
                // we now have to remove existing adunits because we can refresh a subset of them
                if(ozoneWrapper.adserverRequestSent) {
                    ozoneLog('Ads have already been requested! We will not call pbjs.requestBids');
                    return;
                }
                ozoneLog('going to call pbjs.requestBids');
                pbjs.removeAdUnit(); // clear out any existing adunits.
                pbjs.addAdUnits(goodAdUnits);// NOTE that there might be a delay while we locate the CMP, to then update the pbjs.config and THEN wait for the response
                ozoneWrapper.startPrebidTimeout(PREBID_TIMEOUT);
                pbjs.requestBids({
                    // updated code - we have to send a parameter to sendAdserverRequest now
                    bidsBackHandler: function() {
                        if(!ozoneWrapper.adserverRequestSent) {
                            ozoneLog('Bidsbackhandler going to call sendAdserverRequest');
                            ozoneWrapper.sendAdserverRequest(arrDivids);
                        } else {
                            ozoneLog('Bidsbackhandler will not call sendAdserverRequest - its already been called');
                        }
                    }
                });
            });
        });

    },

    /**
     * Check the URI & see what rule matches for section hub/content or homepage then find this in the adunits array.
     * Change the adunit.code to be the divId and add it to the arr array
     *
     * NOTE we will recurse this IF we fail to find an adslot for the given matchSection/divId
     *
     * @param arr Array (Passed By Reference; push objects into this array)
     * @param matchSection string like 'news_content'
     * @param divId string - set the adunit code to this  in each adunit we push into the array; this is necessary for prebid to understand what adunit each bid is for
     * @param googletagTargeting Object - add this into the targeting we send to auction (this might not be needed...)
     * in our list of adunits our `code` value is not the correct adunit code in the dom, but the googletag `position` value
     *
     * @return int the amount of adunits pushed into the array
     */
    pushAdunitForUri: function(arr, matchSection, divId, googletagTargeting) {
        let count = 0;
        for(let i = 0; i < window.adUnits.length; i++) {
            let thisCodeArray = window.adUnits[i].code.toString().split('|');
            let thisAdunitSection = thisCodeArray[0]; // eg sport
            let thisAdunitCode = thisCodeArray[1]; // eg dotcom-slot-leaderboard
            if(thisAdunitSection === matchSection && thisAdunitCode === divId) {
                // update the adunit code & add the googletag.targeting k/vs as we insert the adunit into the main list:
                let adClone = JSON.parse(JSON.stringify(window.adUnits[i]));
                ozoneLog(`MATCHED: ${matchSection}|${divId} ${window.adUnits[i].code.toString()} - updated adunit.code to: ${divId} & added adunit to list for auction`);
                adClone.code = divId;
                Object.assign(adClone.bids[0].params.customData[0].targeting, googletagTargeting);
                adClone.bids[0].params.customData[0].targeting['cont_type'] = ozoneWrapper.getSecOrArt();
                adClone.bids[0].params.customData[0].targeting['section'] = matchSection;
                adClone.bids[0].params.customData[0].targeting['gs_cat'] = googletag.pubads().getTargeting('gs_cat');
                adClone.bids[0].params.customData[0].targeting['asset_type'] = googletag.pubads().getTargeting('asset_type');
                adClone.bids[0].params.customData[0].targeting['testgroup'] = String(testgroup);
                arr.push(adClone);
                ozoneLog('pushed adunit: ', adClone);
                count++;
            } else {
                ozoneLog(`Not matched: ${matchSection}|${divId} ${window.adUnits[i].code.toString()}`);
            }
        }
        if(matchSection !== 'ros' && count === 0) {
            ozoneLog(`pushAdunitForUri: We did identify the section ${matchSection} from the uri BUT we failed to find an adunit for ${matchSection}|${divId} SO we will see if we can find ros|${divId} `)
            return ozoneWrapper.pushAdunitForUri(arr, 'ros', divId, googletagTargeting);
        } else if (count === 0) {
            ozoneLog(`pushAdunitForUri: We did identify the section ${matchSection} from the uri BUT we failed to find an adunit for ${matchSection}|${divId} AND we also failed to find ros|${divId} `)
        }
        return count;
    },
    /**
     * Is this a section page or an article page?
     *
     * look for <meta property="og:type" content="article">
     *
     * document.querySelectorAll('meta[property="og:type"]')[0].getAttribute('content')
     'article'
     *
     * @return string 'sec' or 'art'
     */
    getSecOrArt: function() {
        let arrMeta = document.querySelectorAll('meta[property="og:type"]');
        for(let i = 0; i < arrMeta.length; i++) {
            ozoneLog('got og:type element: ', arrMeta[i]);
            if(arrMeta[i].getAttribute('content') === 'article') {
                return 'art';
            }
        }
        return 'sec';
    },

    // only define these once; we will use these in getMatchSectionFromUri()
    // these are just mappings for adunit codes in adunits.js => regex match against document.location.pathname
    // so they are 100% flexible
    adunitNameRegexMatches: {
        'sport': /^\/sport/,
        'news_hub': /^\/news\/?$/,
        'home': /^\/?$/,
        'business': /^\/news\/business/,
        'culture': /^\/culture/,
        'entertainment': /^\/news\/entertainment(_and_arts|-arts)/,
        'future': /^\/future/,
        'sci_env': /^\/news\/science(_and_environment|-environment)/,
        'technology': /^\/news\/technology/,
        'travel': /^\/travel/,
        'worklife': /^\/worklife/,
        'weather': /^\/weather/,
        'news_content': /^\/news\/.+$/,
        /* NOTE THAT "ros" (run of site) will be used when we can't match anything else. Don't specify it here. */
    },

    /**
     * return the match section to match against in each window.adunits[n].code
     * eg. '/ozone/20220606-bbc-wrapper/bbc_test/sport/some_article.html' would be 'sport'
     * @param uri
     * @return string either the key to match from adunitNameRegexMatches or "ros"
     */
    getMatchSectionFromUri: function(uri) {
        let keys = Object.keys(this.adunitNameRegexMatches);
        for(let i = 0; i < keys.length; i++) {
            let adunitNameFragment = keys[i];
            let regexMatch = this.adunitNameRegexMatches[adunitNameFragment];
            ozoneLog(`trying to match ${regexMatch} against ${uri} - adunitNameFragment is ${adunitNameFragment}`);
            if(uri.match(regexMatch)) {
                return adunitNameFragment;
            }
        }
        return 'ros';
    },

    /**
     * Call the adserver.
     * Updated: we now get sent an (optional) list of div IDs to restrict to
     * Refresh a set of divIds (send null or [] to refresh all)
     * @param arrOptionalDivids Array of divIds (optional)
     */
    sendAdserverRequest: function(arrOptionalDivids) {
        ozoneLog('In sendAdserverRequest : ozoneWrapper.adserverRequestSent = ' + ozoneWrapper.adserverRequestSent);
        ozoneWrapper.adserverRequestSent = true;
        ozoneLog('sendAdserverRequest going to refresh ads', arrOptionalDivids);
        googletag.cmd.push(function () {
            pbjs.que.push(function () {
                pbjs.setTargetingForGPTAsync();
                ozoneWrapper.setCustomGptKeys();
                if(Array.isArray(arrOptionalDivids) && arrOptionalDivids.length > 0) {
    ozoneLog('sendAdserverRequest going to refresh list of adunit IDs: ', arrOptionalDivids);
    googletag.pubads().refresh(ozoneWrapper.getGoogletagSlotsForDivIds(arrOptionalDivids));
} else {
    ozoneLog('sendAdserverRequest going to refresh ALL adunits');
    googletag.pubads().refresh();
}
                
            });
        });
    },
    /**
     * immediately after setting gptasync we need to put testgroup on adslots we've got bids for
     */
    setCustomGptKeys: function() {
        ozoneLog(`setCustomGptKeys going to set testgroup key (testgroup=${testgroup}) on adslots`);
        // you cannot set testgroup globally at this point - googletag complains with an error
        let slots = googletag.pubads().getSlots();
        for(let slot of slots) {
            slot.setTargeting('testgroup', testgroup);
        }
    },
    // new code - convenience method for getting a list of googletag slot objects from div ids
    getGoogletagSlotsForDivIds: function(arrDivids) {
        ozoneLog('Going to filter googletag slots by list: ', arrDivids);
        let sm = googletag.pubads().getSlots();
        return sm.filter(element => {return arrDivids.indexOf(element.getSlotElementId()) > -1; });
    },
    /**
     * set the value of ozoneWrapper.cmpGdpr
     *  - luckily this seems to be fully synchronous:
     */
    setCmpGdpr: function() {
        ozoneLog('**** test before checking window.__tcfapi');
        if(!window.hasOwnProperty('__tcfapi')) {
            ozoneLog('**** there is no window.__tcfapi function; assuming it will be here at some point so will wait for it...');
            ozoneLog('setCmpGdpr going to call the completion function');
            return;
        }
        window.__tcfapi('ping', 2, (pingReturn) => {
            // do something with pingReturn
            ozoneLog('**** test inside window.__tcfapi');
            ozoneLog(`Found __tcfapi info after ${ozoneWrapper.tcfapiLocator.searchMsElapsed()}ms:`);
            ozoneLog(pingReturn);
            if(pingReturn.cmpLoaded) {
                ozoneLog(`__tcfapi CMP is Loaded, success getting gdprApplies value ${pingReturn.gdprApplies}`);
                ozoneWrapper.cmpGdpr = pingReturn.gdprApplies;
            } else {
                ozoneLog(`__tcfapi cmpLoaded is false: pingReturn: ${JSON.stringify(pingReturn)}`);
            }
        });
        ozoneLog('**** test after window.__tcfapi');
    },

    /**
     * trying window.__uspapi('uspPing',...) as this is likely to be quicker than 'getUSPData'
     *
     * https://help.quantcast.com/hc/en-us/articles/360047078534-Choice-CMP2-CCPA-API-Index-TCF-v2-0-
     *
     * 20220601 - window.__uspapi might not exist, also if we don't find a value on first try we must return false (don't keep trying to find it)
     *
     * @param fnOnCompletion: function - call this on completion
     */
    setCmpUsp: function(fnOnCompletion) {
        ozoneLog('**** test before checking window.__uspapi');
        if(!window.hasOwnProperty('__uspapi')) {
            ozoneLog('**** there is no window.__uspapi function - returning/setting false for USP; will not retry - if it was going to be here it would be here by now');
            ozoneWrapper.cmpUsp = false;
            ozoneLog('setCmpUsp going to call the completion function');
            fnOnCompletion();
            return;
        }
        window.__uspapi('getUSPData', 1, function(obj, status) {
            ozoneLog('**** test inside callback for window.__uspapi');
            if(obj.uspString) {
                if(obj.uspString.match('---')) {
                    ozoneLog(`USP is NOT active for this user; uspString is ${obj.uspString}`);
                    ozoneWrapper.cmpUsp = false;
                } else {
                    ozoneLog(`USP is active for this user; uspString is ${obj.uspString}`);
                    ozoneWrapper.cmpUsp = true;
                }
            } else {
                // otherwise leave the value of ozoneWrapper.cmpUsp as null
                ozoneLog('USP data is not ready yet');
            }
            ozoneLog('setCmpUsp going to call the completion function');
            fnOnCompletion();
        });
        ozoneLog('**** test after window.__uspapi');
    },

    // /**
    //  * set the value of ozoneWrapper.cmpUsp
    //  * - Unfortunately this is Asynchronous!
    //  */
    // setCmpUsp_async: function() {
    //     ozoneLog('**** test before window.__uspapi');
    //     window.__uspapi('getUSPData', 1, (uspData, success) => {
    //         ozoneLog('**** test inside window.__uspapi');
    //         if (success) {
    //             ozoneLog('success getting __uspapi(\'getUSPData\'...)');
    //             console.log(uspData);
    //             // https://github.com/InteractiveAdvertisingBureau/USPrivacy/blob/master/CCPA/USP%20API.md
    //             // 1--- means n/a
    //             ozoneWrapper.cmpUsp = uspData.uspString !== "1---";
    //         } else {
    //             console.log('not success getting __uspapi(\'getUSPData\'...)');
    //         }
    //     });
    //     ozoneLog('**** test after window.__uspapi');
    // }
}
ozoneWrapper.tcfapiLocator.init(); // just see if there's any qs value we have to use



if(configVars.includeMenu) {
    //
    // include the menu:
    ///
    var menuFile = document.createElement('script');
    menuFile.src = 'https://www.ardm.io/ozone/20220606-bbc-wrapper/bbc_test/menu.js';
    document.head.appendChild(menuFile); // using appendChild should cause this to load asynchronously
    ozoneLog('pbjs.js: included menu');
} else {
    ozoneLog('skipping menu');
}

// simple wrapper function
function ozoneFetchBids() {
    ozoneWrapper.ozoneFetchBids.apply(null, arguments);
}

ozoneLog('setting long backstop timeout to call adserver if theres some very long problem with all the complex stuff thats going on with cmp->config rewriting->prebid');
ozoneWrapper.startPrebidTimeout(10000); // backstop

ozoneLog('bottom of Ozone pbjs.js');